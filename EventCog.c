/* EventCog.c generated by valac 0.34.4, the Vala compiler
 * generated from EventCog.vala, do not modify */

/*Copyright (C) 2013 Mattias Münster

Author: Mattias Münster <mattiasmun@gmail.com>

This file is part of valamathg.

valamathg is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

valamathg is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with valamathg.  If not, see <http://www.gnu.org/licenses/>.*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gtk/gtk.h>
#include <float.h>
#include <math.h>
#include <gdk/gdk.h>


#define MATHG_TYPE_EVENT_COG (mathg_event_cog_get_type ())
#define MATHG_EVENT_COG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MATHG_TYPE_EVENT_COG, mathgEventCog))
#define MATHG_EVENT_COG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MATHG_TYPE_EVENT_COG, mathgEventCogClass))
#define MATHG_IS_EVENT_COG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MATHG_TYPE_EVENT_COG))
#define MATHG_IS_EVENT_COG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MATHG_TYPE_EVENT_COG))
#define MATHG_EVENT_COG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MATHG_TYPE_EVENT_COG, mathgEventCogClass))

typedef struct _mathgEventCog mathgEventCog;
typedef struct _mathgEventCogClass mathgEventCogClass;
typedef struct _mathgEventCogPrivate mathgEventCogPrivate;

#define MATHG_TYPE_MATH_COG (mathg_math_cog_get_type ())

#define MATHG_TYPE_NUMBER_UTILS (mathg_number_utils_get_type ())
typedef struct _mathgNumberUtils mathgNumberUtils;

#define MATHG_TYPE_OPERATE (mathg_operate_get_type ())
typedef struct _mathgOperate mathgOperate;

#define MATHG_TYPE_MY_TIMER (mathg_my_timer_get_type ())
typedef struct _mathgMyTimer mathgMyTimer;

#define MATHG_TYPE_ELMNT (mathg_elmnt_get_type ())
typedef struct _mathgElmnt mathgElmnt;
typedef struct _mathgMathCog mathgMathCog;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _mathgEventCog {
	GtkViewport parent_instance;
	mathgEventCogPrivate * priv;
};

struct _mathgEventCogClass {
	GtkViewportClass parent_class;
};

struct _mathgNumberUtils {
	gint bas;
};

struct _mathgOperate {
	gdouble min;
	gdouble span;
	gint term;
	gchar* type;
};

struct _mathgMyTimer {
	gboolean reset;
	GDateTime* start;
	GDateTime* stop;
};

struct _mathgElmnt {
	gdouble answer;
	gchar* guess;
	gchar* question;
	gchar* result;
};

struct _mathgMathCog {
	gchar* ch;
	gdouble cor;
	gdouble deviation;
	gdouble err;
	gboolean isenter;
	mathgNumberUtils nu;
	mathgOperate operation;
	gint pm;
	mathgMyTimer problem;
	gchar* res;
	mathgElmnt* stra;
	gint stra_length1;
	gint straind;
	mathgMyTimer total;
};

struct _mathgEventCogPrivate {
	gboolean ctrl;
	mathgMathCog mc;
	guint kod;
	GtkLabel** lb;
	gint lb_length1;
	gint _lb_size_;
};


static gpointer mathg_event_cog_parent_class = NULL;

GType mathg_event_cog_get_type (void) G_GNUC_CONST;
GType mathg_math_cog_get_type (void) G_GNUC_CONST;
GType mathg_number_utils_get_type (void) G_GNUC_CONST;
mathgNumberUtils* mathg_number_utils_dup (const mathgNumberUtils* self);
void mathg_number_utils_free (mathgNumberUtils* self);
GType mathg_operate_get_type (void) G_GNUC_CONST;
mathgOperate* mathg_operate_dup (const mathgOperate* self);
void mathg_operate_free (mathgOperate* self);
void mathg_operate_copy (const mathgOperate* self, mathgOperate* dest);
void mathg_operate_destroy (mathgOperate* self);
GType mathg_my_timer_get_type (void) G_GNUC_CONST;
mathgMyTimer* mathg_my_timer_dup (const mathgMyTimer* self);
void mathg_my_timer_free (mathgMyTimer* self);
void mathg_my_timer_copy (const mathgMyTimer* self, mathgMyTimer* dest);
void mathg_my_timer_destroy (mathgMyTimer* self);
GType mathg_elmnt_get_type (void) G_GNUC_CONST;
mathgElmnt* mathg_elmnt_dup (const mathgElmnt* self);
void mathg_elmnt_free (mathgElmnt* self);
void mathg_elmnt_copy (const mathgElmnt* self, mathgElmnt* dest);
void mathg_elmnt_destroy (mathgElmnt* self);
mathgMathCog* mathg_math_cog_dup (const mathgMathCog* self);
void mathg_math_cog_free (mathgMathCog* self);
void mathg_math_cog_copy (const mathgMathCog* self, mathgMathCog* dest);
void mathg_math_cog_destroy (mathgMathCog* self);
#define MATHG_EVENT_COG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), MATHG_TYPE_EVENT_COG, mathgEventCogPrivate))
enum  {
	MATHG_EVENT_COG_DUMMY_PROPERTY
};
mathgEventCog* mathg_event_cog_new (gchar** args, int args_length1);
mathgEventCog* mathg_event_cog_construct (GType object_type, gchar** args, int args_length1);
void mathg_math_cog_init (mathgMathCog *self, gchar** args, int args_length1);
static void mathg_event_cog_caseixy (mathgEventCog* self, gint i);
gchar* mathg_elmnt_to_string (mathgElmnt *self);
static gboolean mathg_event_cog_is_ctrl (mathgEventCog* self);
static gboolean mathg_event_cog_is_enter (mathgEventCog* self);
static gboolean mathg_event_cog_real_key_press_event (GtkWidget* base, GdkEventKey* event);
void mathg_math_cog_bsp (mathgMathCog *self);
void mathg_math_cog_generate (mathgMathCog *self);
void mathg_math_cog_put (mathgMathCog *self);
void mathg_event_cog_repaint (mathgEventCog* self);
static gboolean mathg_event_cog_real_key_release_event (GtkWidget* base, GdkEventKey* event);
static gboolean mathg_event_cog_real_scroll_event (GtkWidget* base, GdkEventScroll* event);
static void mathg_event_cog_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

const gchar* MATHG_sa[2] = {"font=\"40\"", "font=\"20\""};

mathgEventCog* mathg_event_cog_construct (GType object_type, gchar** args, int args_length1) {
	mathgEventCog * self = NULL;
	GtkGrid* g = NULL;
	GtkGrid* _tmp0_ = NULL;
	GtkLabel** _tmp1_ = NULL;
	GtkGrid* _tmp17_ = NULL;
	gchar** _tmp18_ = NULL;
	gint _tmp18__length1 = 0;
	self = (mathgEventCog*) g_object_new (object_type, NULL);
	_tmp0_ = (GtkGrid*) gtk_grid_new ();
	g_object_ref_sink (_tmp0_);
	g = _tmp0_;
	_tmp1_ = g_new0 (GtkLabel*, 4 + 1);
	self->priv->lb = (_vala_array_free (self->priv->lb, self->priv->lb_length1, (GDestroyNotify) g_object_unref), NULL);
	self->priv->lb = _tmp1_;
	self->priv->lb_length1 = 4;
	self->priv->_lb_size_ = self->priv->lb_length1;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gint _tmp4_ = 0;
				GtkLabel** _tmp5_ = NULL;
				gint _tmp5__length1 = 0;
				gint _tmp6_ = 0;
				gint _tmp7_ = 0;
				gchar* _tmp8_ = NULL;
				gchar* _tmp9_ = NULL;
				GtkLabel* _tmp10_ = NULL;
				GtkLabel* _tmp11_ = NULL;
				GtkGrid* _tmp12_ = NULL;
				GtkLabel** _tmp13_ = NULL;
				gint _tmp13__length1 = 0;
				gint _tmp14_ = 0;
				GtkLabel* _tmp15_ = NULL;
				gint _tmp16_ = 0;
				if (!_tmp2_) {
					gint _tmp3_ = 0;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = i;
				if (!(_tmp4_ < 4)) {
					break;
				}
				_tmp5_ = self->priv->lb;
				_tmp5__length1 = self->priv->lb_length1;
				_tmp6_ = i;
				_tmp7_ = i;
				_tmp8_ = g_strdup_printf ("%i", _tmp7_);
				_tmp9_ = _tmp8_;
				_tmp10_ = (GtkLabel*) gtk_label_new (_tmp9_);
				g_object_ref_sink (_tmp10_);
				_g_object_unref0 (_tmp5_[_tmp6_]);
				_tmp5_[_tmp6_] = _tmp10_;
				_tmp11_ = _tmp5_[_tmp6_];
				_g_free0 (_tmp9_);
				_tmp12_ = g;
				_tmp13_ = self->priv->lb;
				_tmp13__length1 = self->priv->lb_length1;
				_tmp14_ = i;
				_tmp15_ = _tmp13_[_tmp14_];
				_tmp16_ = i;
				gtk_grid_attach (_tmp12_, (GtkWidget*) _tmp15_, 1, _tmp16_, 1, 1);
			}
		}
	}
	_tmp17_ = g;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp17_);
	_tmp18_ = args;
	_tmp18__length1 = args_length1;
	mathg_math_cog_destroy (&self->priv->mc);
	mathg_math_cog_init (&self->priv->mc, _tmp18_, _tmp18__length1);
	g_object_set ((GtkWidget*) self, "can-focus", TRUE, NULL);
	gtk_widget_grab_focus ((GtkWidget*) self);
	_g_object_unref0 (g);
	return self;
}


mathgEventCog* mathg_event_cog_new (gchar** args, int args_length1) {
	return mathg_event_cog_construct (MATHG_TYPE_EVENT_COG, args, args_length1);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static void mathg_event_cog_caseixy (mathgEventCog* self, gint i) {
	gint j = 0;
	mathgMathCog _tmp0_ = {0};
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gboolean _tmp3_ = FALSE;
	mathgMathCog _tmp4_ = {0};
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->mc;
	_tmp1_ = _tmp0_.straind;
	_tmp2_ = i;
	j = (_tmp1_ + _tmp2_) - 1;
	_tmp4_ = self->priv->mc;
	_tmp5_ = _tmp4_.straind;
	_tmp6_ = i;
	if ((_tmp5_ + _tmp6_) > 0) {
		gint _tmp7_ = 0;
		mathgMathCog _tmp8_ = {0};
		mathgElmnt* _tmp9_ = NULL;
		gint _tmp9__length1 = 0;
		_tmp7_ = j;
		_tmp8_ = self->priv->mc;
		_tmp9_ = _tmp8_.stra;
		_tmp9__length1 = _tmp8_.stra_length1;
		_tmp3_ = _tmp7_ < _tmp9__length1;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		gchar* s = NULL;
		gint _tmp10_ = 0;
		gint _tmp11_ = 0;
		const gchar* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		gchar* _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		mathgMathCog _tmp17_ = {0};
		mathgElmnt* _tmp18_ = NULL;
		gint _tmp18__length1 = 0;
		gint _tmp19_ = 0;
		gchar* _tmp20_ = NULL;
		gchar* _tmp21_ = NULL;
		gchar* _tmp22_ = NULL;
		GtkLabel** _tmp23_ = NULL;
		gint _tmp23__length1 = 0;
		gint _tmp24_ = 0;
		GtkLabel* _tmp25_ = NULL;
		const gchar* _tmp26_ = NULL;
		_tmp10_ = i;
		_tmp11_ = abs (_tmp10_ - 1);
		_tmp12_ = MATHG_sa[_tmp11_];
		_tmp13_ = string_to_string (_tmp12_);
		_tmp14_ = g_strconcat ("<span ", _tmp13_, ">", NULL);
		s = _tmp14_;
		_tmp15_ = s;
		_tmp16_ = string_to_string (_tmp15_);
		_tmp17_ = self->priv->mc;
		_tmp18_ = _tmp17_.stra;
		_tmp18__length1 = _tmp17_.stra_length1;
		_tmp19_ = j;
		_tmp20_ = mathg_elmnt_to_string (&_tmp18_[_tmp19_]);
		_tmp21_ = _tmp20_;
		_tmp22_ = g_strconcat (_tmp16_, _tmp21_, "</span>", NULL);
		_g_free0 (s);
		s = _tmp22_;
		_g_free0 (_tmp21_);
		_tmp23_ = self->priv->lb;
		_tmp23__length1 = self->priv->lb_length1;
		_tmp24_ = i;
		_tmp25_ = _tmp23_[_tmp24_];
		_tmp26_ = s;
		gtk_label_set_markup (_tmp25_, _tmp26_);
		_g_free0 (s);
	} else {
		GtkLabel** _tmp27_ = NULL;
		gint _tmp27__length1 = 0;
		gint _tmp28_ = 0;
		GtkLabel* _tmp29_ = NULL;
		const gchar* _tmp30_ = NULL;
		const gchar* _tmp31_ = NULL;
		gchar* _tmp32_ = NULL;
		gchar* _tmp33_ = NULL;
		_tmp27_ = self->priv->lb;
		_tmp27__length1 = self->priv->lb_length1;
		_tmp28_ = i;
		_tmp29_ = _tmp27_[_tmp28_];
		_tmp30_ = MATHG_sa[1];
		_tmp31_ = string_to_string (_tmp30_);
		_tmp32_ = g_strconcat ("<span ", _tmp31_, "> </span>", NULL);
		_tmp33_ = _tmp32_;
		gtk_label_set_markup (_tmp29_, _tmp33_);
		_g_free0 (_tmp33_);
	}
}


static gboolean mathg_event_cog_is_ctrl (mathgEventCog* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	guint _tmp1_ = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = self->priv->kod;
	if (_tmp1_ == ((guint) GDK_KEY_Control_L)) {
		_tmp0_ = TRUE;
	} else {
		guint _tmp2_ = 0U;
		_tmp2_ = self->priv->kod;
		_tmp0_ = _tmp2_ == ((guint) GDK_KEY_Control_R);
	}
	result = _tmp0_;
	return result;
}


static gboolean mathg_event_cog_is_enter (mathgEventCog* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	guint _tmp2_ = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp2_ = self->priv->kod;
	if (_tmp2_ == ((guint) GDK_KEY_KP_Enter)) {
		_tmp1_ = TRUE;
	} else {
		guint _tmp3_ = 0U;
		_tmp3_ = self->priv->kod;
		_tmp1_ = _tmp3_ == ((guint) GDK_KEY_Return);
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		guint _tmp4_ = 0U;
		_tmp4_ = self->priv->kod;
		_tmp0_ = _tmp4_ == ((guint) GDK_KEY_space);
	}
	result = _tmp0_;
	return result;
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		GRegex* regex = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GRegex* _tmp3_ = NULL;
		GRegex* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GRegex* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp6_ = regex;
		_tmp7_ = replacement;
		_tmp8_ = g_regex_replace_literal (_tmp6_, self, (gssize) -1, 0, _tmp7_, 0, &_inner_error_);
		_tmp5_ = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp9_ = _tmp5_;
		_tmp5_ = NULL;
		result = _tmp9_;
		_g_free0 (_tmp5_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally0;
	__catch0_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static gboolean mathg_event_cog_real_key_press_event (GtkWidget* base, GdkEventKey* event) {
	mathgEventCog * self;
	gboolean result = FALSE;
	GdkEventKey* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	GdkEventKey* _tmp3_ = NULL;
	guint _tmp4_ = 0U;
	gboolean _tmp5_ = FALSE;
	guint _tmp6_ = 0U;
	gboolean _tmp9_ = FALSE;
	gboolean _tmp10_ = FALSE;
	mathgMathCog _tmp12_ = {0};
	mathgElmnt* _tmp13_ = NULL;
	gint _tmp13__length1 = 0;
	mathgMathCog _tmp14_ = {0};
	gint _tmp15_ = 0;
	mathgElmnt _tmp16_ = {0};
	const gchar* _tmp17_ = NULL;
	self = (mathgEventCog*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = event;
	_tmp1_ = _tmp0_->string;
	_tmp2_ = string_replace (_tmp1_, "§", "0");
	_g_free0 (self->priv->mc.ch);
	self->priv->mc.ch = _tmp2_;
	_tmp3_ = event;
	_tmp4_ = _tmp3_->keyval;
	self->priv->kod = _tmp4_;
	_tmp5_ = mathg_event_cog_is_enter (self);
	self->priv->mc.isenter = _tmp5_;
	_tmp6_ = self->priv->kod;
	switch (_tmp6_) {
		case GDK_KEY_BackSpace:
		{
			mathg_math_cog_bsp (&self->priv->mc);
			break;
		}
		case GDK_KEY_Q:
		case GDK_KEY_q:
		{
			gboolean _tmp7_ = FALSE;
			_tmp7_ = self->priv->ctrl;
			if (_tmp7_) {
				gtk_main_quit ();
			}
			break;
		}
		case GDK_KEY_R:
		case GDK_KEY_r:
		{
			gboolean _tmp8_ = FALSE;
			_tmp8_ = self->priv->ctrl;
			if (_tmp8_) {
				mathg_math_cog_generate (&self->priv->mc);
			}
			break;
		}
		default:
		break;
	}
	_tmp10_ = mathg_event_cog_is_ctrl (self);
	if (_tmp10_) {
		_tmp9_ = TRUE;
	} else {
		gboolean _tmp11_ = FALSE;
		_tmp11_ = self->priv->ctrl;
		_tmp9_ = _tmp11_;
	}
	self->priv->ctrl = _tmp9_;
	_tmp12_ = self->priv->mc;
	_tmp13_ = _tmp12_.stra;
	_tmp13__length1 = _tmp12_.stra_length1;
	_tmp14_ = self->priv->mc;
	_tmp15_ = _tmp14_.straind;
	_tmp16_ = _tmp13_[_tmp15_];
	_tmp17_ = _tmp16_.result;
	if (_tmp17_ == NULL) {
		mathg_math_cog_put (&self->priv->mc);
	}
	mathg_event_cog_repaint (self);
	result = TRUE;
	return result;
}


static gboolean mathg_event_cog_real_key_release_event (GtkWidget* base, GdkEventKey* event) {
	mathgEventCog * self;
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	self = (mathgEventCog*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp1_ = mathg_event_cog_is_ctrl (self);
	if (_tmp1_) {
		_tmp0_ = FALSE;
	} else {
		gboolean _tmp2_ = FALSE;
		_tmp2_ = self->priv->ctrl;
		_tmp0_ = _tmp2_;
	}
	self->priv->ctrl = _tmp0_;
	result = TRUE;
	return result;
}


void mathg_event_cog_repaint (mathgEventCog* self) {
	GtkLabel** _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	GtkLabel* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	mathgMathCog _tmp8_ = {0};
	const gchar* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	g_return_if_fail (self != NULL);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp2_ = 0;
				gint _tmp3_ = 0;
				if (!_tmp0_) {
					gint _tmp1_ = 0;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp2_ = i;
				if (!(_tmp2_ < 3)) {
					break;
				}
				_tmp3_ = i;
				mathg_event_cog_caseixy (self, _tmp3_);
			}
		}
	}
	_tmp4_ = self->priv->lb;
	_tmp4__length1 = self->priv->lb_length1;
	_tmp5_ = _tmp4_[3];
	_tmp6_ = MATHG_sa[1];
	_tmp7_ = string_to_string (_tmp6_);
	_tmp8_ = self->priv->mc;
	_tmp9_ = _tmp8_.res;
	_tmp10_ = string_to_string (_tmp9_);
	_tmp11_ = g_strconcat ("<span ", _tmp7_, ">", _tmp10_, "</span>", NULL);
	_tmp12_ = _tmp11_;
	gtk_label_set_markup (_tmp5_, _tmp12_);
	_g_free0 (_tmp12_);
}


static gboolean mathg_event_cog_real_scroll_event (GtkWidget* base, GdkEventScroll* event) {
	mathgEventCog * self;
	gboolean result = FALSE;
	gint scr = 0;
	GdkEventScroll* _tmp0_ = NULL;
	gdouble _tmp1_ = 0.0;
	gint _tmp2_ = 0;
	gboolean _tmp3_ = FALSE;
	mathgMathCog _tmp4_ = {0};
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	mathgMathCog _tmp7_ = {0};
	mathgElmnt* _tmp8_ = NULL;
	gint _tmp8__length1 = 0;
	gint _tmp13_ = 0;
	self = (mathgEventCog*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = event;
	_tmp1_ = _tmp0_->delta_y;
	scr = (gint) _tmp1_;
	_tmp4_ = self->priv->mc;
	_tmp5_ = _tmp4_.straind;
	_tmp6_ = scr;
	_tmp7_ = self->priv->mc;
	_tmp8_ = _tmp7_.stra;
	_tmp8__length1 = _tmp7_.stra_length1;
	if ((_tmp5_ + _tmp6_) < _tmp8__length1) {
		mathgMathCog _tmp9_ = {0};
		gint _tmp10_ = 0;
		gint _tmp11_ = 0;
		_tmp9_ = self->priv->mc;
		_tmp10_ = _tmp9_.straind;
		_tmp11_ = scr;
		_tmp3_ = (_tmp10_ + _tmp11_) >= 0;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		gint _tmp12_ = 0;
		_tmp12_ = scr;
		_tmp2_ = _tmp12_;
	} else {
		_tmp2_ = 0;
	}
	_tmp13_ = self->priv->mc.straind;
	self->priv->mc.straind = _tmp13_ + _tmp2_;
	mathg_event_cog_repaint (self);
	result = TRUE;
	return result;
}


static void mathg_event_cog_class_init (mathgEventCogClass * klass) {
	mathg_event_cog_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (mathgEventCogPrivate));
	((GtkWidgetClass *) klass)->key_press_event = mathg_event_cog_real_key_press_event;
	((GtkWidgetClass *) klass)->key_release_event = mathg_event_cog_real_key_release_event;
	((GtkWidgetClass *) klass)->scroll_event = mathg_event_cog_real_scroll_event;
	G_OBJECT_CLASS (klass)->finalize = mathg_event_cog_finalize;
}


static void mathg_event_cog_instance_init (mathgEventCog * self) {
	self->priv = MATHG_EVENT_COG_GET_PRIVATE (self);
	self->priv->ctrl = FALSE;
}


static void mathg_event_cog_finalize (GObject* obj) {
	mathgEventCog * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MATHG_TYPE_EVENT_COG, mathgEventCog);
	mathg_math_cog_destroy (&self->priv->mc);
	self->priv->lb = (_vala_array_free (self->priv->lb, self->priv->lb_length1, (GDestroyNotify) g_object_unref), NULL);
	G_OBJECT_CLASS (mathg_event_cog_parent_class)->finalize (obj);
}


GType mathg_event_cog_get_type (void) {
	static volatile gsize mathg_event_cog_type_id__volatile = 0;
	if (g_once_init_enter (&mathg_event_cog_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (mathgEventCogClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) mathg_event_cog_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (mathgEventCog), 0, (GInstanceInitFunc) mathg_event_cog_instance_init, NULL };
		GType mathg_event_cog_type_id;
		mathg_event_cog_type_id = g_type_register_static (gtk_viewport_get_type (), "mathgEventCog", &g_define_type_info, 0);
		g_once_init_leave (&mathg_event_cog_type_id__volatile, mathg_event_cog_type_id);
	}
	return mathg_event_cog_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



