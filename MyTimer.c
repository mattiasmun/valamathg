/* MyTimer.c generated by valac 0.20.1, the Vala compiler
 * generated from MyTimer.vala, do not modify */

/*Copyright (C) 2013 Mattias Münster

Author: Mattias Münster <mattiasmun@gmail.com>

This file is part of valamathg.

valamathg is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

valamathg is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with valamathg.  If not, see <http://www.gnu.org/licenses/>.*/

#include <glib.h>
#include <glib-object.h>
#include <string.h>
#include <stdlib.h>


#define MATHG_TYPE_MY_TIMER (mathg_my_timer_get_type ())
typedef struct _mathgMyTimer mathgMyTimer;
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _mathgMyTimer {
	gboolean reset;
	GDateTime* start;
	GDateTime* stop;
};



GType mathg_my_timer_get_type (void) G_GNUC_CONST;
mathgMyTimer* mathg_my_timer_dup (const mathgMyTimer* self);
void mathg_my_timer_free (mathgMyTimer* self);
void mathg_my_timer_copy (const mathgMyTimer* self, mathgMyTimer* dest);
void mathg_my_timer_destroy (mathgMyTimer* self);
void mathg_my_timer_init (mathgMyTimer *self, gboolean b);
gchar* mathg_my_timer_to_string (mathgMyTimer *self);


static gpointer _g_date_time_ref0 (gpointer self) {
	return self ? g_date_time_ref (self) : NULL;
}


void mathg_my_timer_init (mathgMyTimer *self, gboolean b) {
	gboolean _tmp0_;
	GDateTime* _tmp1_;
	GDateTime* _tmp2_;
	GDateTime* _tmp3_;
	memset (self, 0, sizeof (mathgMyTimer));
	_tmp0_ = b;
	(*self).reset = _tmp0_;
	_tmp1_ = g_date_time_new_now_local ();
	_g_date_time_unref0 ((*self).stop);
	(*self).stop = _tmp1_;
	_tmp2_ = (*self).stop;
	_tmp3_ = _g_date_time_ref0 (_tmp2_);
	_g_date_time_unref0 ((*self).start);
	(*self).start = _tmp3_;
}


gchar* mathg_my_timer_to_string (mathgMyTimer *self) {
	gchar* result = NULL;
	GDateTime* _tmp0_;
	GDateTime* _tmp1_;
	GDateTime* _tmp2_;
	GTimeSpan _tmp3_ = 0LL;
	gchar* _tmp4_ = NULL;
	gchar* s;
	GDateTime* _tmp5_ = NULL;
	gboolean _tmp6_;
	GDateTime* _tmp9_;
	GDateTime* _tmp10_;
	_tmp0_ = g_date_time_new_now_local ();
	_g_date_time_unref0 ((*self).stop);
	(*self).stop = _tmp0_;
	_tmp1_ = (*self).stop;
	_tmp2_ = (*self).start;
	_tmp3_ = g_date_time_difference (_tmp1_, _tmp2_);
	_tmp4_ = g_strdup_printf ("%" G_GINT64_FORMAT, (gint64) ((_tmp3_ + 500L) / 1000L));
	s = _tmp4_;
	_tmp6_ = (*self).reset;
	if (_tmp6_) {
		GDateTime* _tmp7_;
		_tmp7_ = (*self).stop;
		_tmp5_ = _tmp7_;
	} else {
		GDateTime* _tmp8_;
		_tmp8_ = (*self).start;
		_tmp5_ = _tmp8_;
	}
	_tmp9_ = _tmp5_;
	_tmp10_ = _g_date_time_ref0 (_tmp9_);
	_g_date_time_unref0 ((*self).start);
	(*self).start = _tmp10_;
	result = s;
	return result;
}


void mathg_my_timer_copy (const mathgMyTimer* self, mathgMyTimer* dest) {
	gboolean _tmp0_;
	GDateTime* _tmp1_;
	GDateTime* _tmp2_;
	GDateTime* _tmp3_;
	GDateTime* _tmp4_;
	_tmp0_ = (*self).reset;
	(*dest).reset = _tmp0_;
	_tmp1_ = (*self).start;
	_tmp2_ = _g_date_time_ref0 (_tmp1_);
	_g_date_time_unref0 ((*dest).start);
	(*dest).start = _tmp2_;
	_tmp3_ = (*self).stop;
	_tmp4_ = _g_date_time_ref0 (_tmp3_);
	_g_date_time_unref0 ((*dest).stop);
	(*dest).stop = _tmp4_;
}


void mathg_my_timer_destroy (mathgMyTimer* self) {
	_g_date_time_unref0 ((*self).start);
	_g_date_time_unref0 ((*self).stop);
}


mathgMyTimer* mathg_my_timer_dup (const mathgMyTimer* self) {
	mathgMyTimer* dup;
	dup = g_new0 (mathgMyTimer, 1);
	mathg_my_timer_copy (self, dup);
	return dup;
}


void mathg_my_timer_free (mathgMyTimer* self) {
	mathg_my_timer_destroy (self);
	g_free (self);
}


GType mathg_my_timer_get_type (void) {
	static volatile gsize mathg_my_timer_type_id__volatile = 0;
	if (g_once_init_enter (&mathg_my_timer_type_id__volatile)) {
		GType mathg_my_timer_type_id;
		mathg_my_timer_type_id = g_boxed_type_register_static ("mathgMyTimer", (GBoxedCopyFunc) mathg_my_timer_dup, (GBoxedFreeFunc) mathg_my_timer_free);
		g_once_init_leave (&mathg_my_timer_type_id__volatile, mathg_my_timer_type_id);
	}
	return mathg_my_timer_type_id__volatile;
}



