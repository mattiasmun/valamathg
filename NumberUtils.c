/* NumberUtils.c generated by valac 0.34.4, the Vala compiler
 * generated from NumberUtils.vala, do not modify */

/*Copyright (C) 2013 Mattias Münster

Author: Mattias Münster <mattiasmun@gmail.com>

This file is part of valamathg.

valamathg is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

valamathg is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with valamathg.  If not, see <http://www.gnu.org/licenses/>.*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>


#define MATHG_TYPE_NUMBER_UTILS (mathg_number_utils_get_type ())
typedef struct _mathgNumberUtils mathgNumberUtils;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _mathgNumberUtils {
	guint bas;
};



GType mathg_number_utils_get_type (void) G_GNUC_CONST;
mathgNumberUtils* mathg_number_utils_dup (const mathgNumberUtils* self);
void mathg_number_utils_free (mathgNumberUtils* self);
void mathg_number_utils_init (mathgNumberUtils *self, const gchar* s);
gint mathg_number_utils_ti (mathgNumberUtils *self, const gchar* a);
gdouble mathg_number_utils_td (mathgNumberUtils *self, const gchar* a);
gint64 g_ascii_strtoll (const gchar* nptr, gchar** endptr, guint _base);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


void mathg_number_utils_init (mathgNumberUtils *self, const gchar* s) {
	const gchar* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	g_return_if_fail (s != NULL);
	memset (self, 0, sizeof (mathgNumberUtils));
	(*self).bas = (guint) 10;
	_tmp0_ = s;
	_tmp1_ = mathg_number_utils_ti (&(*self), _tmp0_);
	(*self).bas = (guint) _tmp1_;
}


gdouble mathg_number_utils_td (mathgNumberUtils *self, const gchar* a) {
	gdouble result = 0.0;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar** _tmp3_ = NULL;
	gchar** _tmp4_ = NULL;
	gchar** _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	const gchar* _tmp6_ = NULL;
	gint _tmp7_ = 0;
	gdouble _tmp8_ = 0.0;
	g_return_val_if_fail (a != NULL, 0.0);
	_tmp0_ = a;
	_tmp1_ = g_strconcat (_tmp0_, ".", NULL);
	_tmp2_ = _tmp1_;
	_tmp4_ = _tmp3_ = g_strsplit (_tmp2_, ".", 0);
	_tmp5_ = _tmp4_;
	_tmp5__length1 = _vala_array_length (_tmp3_);
	_tmp6_ = _tmp5_[0];
	_tmp7_ = mathg_number_utils_ti (&(*self), _tmp6_);
	_tmp8_ = (gdouble) _tmp7_;
	_tmp5_ = (_vala_array_free (_tmp5_, _tmp5__length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (_tmp2_);
	result = _tmp8_;
	return result;
}


gint mathg_number_utils_ti (mathgNumberUtils *self, const gchar* a) {
	gint result = 0;
	const gchar* _tmp0_ = NULL;
	guint _tmp1_ = 0U;
	gint64 _tmp2_ = 0LL;
	g_return_val_if_fail (a != NULL, 0);
	_tmp0_ = a;
	_tmp1_ = (*self).bas;
	_tmp2_ = g_ascii_strtoll (_tmp0_, NULL, _tmp1_);
	result = (gint) _tmp2_;
	return result;
}


mathgNumberUtils* mathg_number_utils_dup (const mathgNumberUtils* self) {
	mathgNumberUtils* dup;
	dup = g_new0 (mathgNumberUtils, 1);
	memcpy (dup, self, sizeof (mathgNumberUtils));
	return dup;
}


void mathg_number_utils_free (mathgNumberUtils* self) {
	g_free (self);
}


GType mathg_number_utils_get_type (void) {
	static volatile gsize mathg_number_utils_type_id__volatile = 0;
	if (g_once_init_enter (&mathg_number_utils_type_id__volatile)) {
		GType mathg_number_utils_type_id;
		mathg_number_utils_type_id = g_boxed_type_register_static ("mathgNumberUtils", (GBoxedCopyFunc) mathg_number_utils_dup, (GBoxedFreeFunc) mathg_number_utils_free);
		g_once_init_leave (&mathg_number_utils_type_id__volatile, mathg_number_utils_type_id);
	}
	return mathg_number_utils_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



