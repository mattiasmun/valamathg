/* NumberUtils.c generated by valac 0.34.4, the Vala compiler
 * generated from NumberUtils.vala, do not modify */

/*Copyright (C) 2013 Mattias Münster

Author: Mattias Münster <mattiasmun@gmail.com>

This file is part of valamathg.

valamathg is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

valamathg is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with valamathg.  If not, see <http://www.gnu.org/licenses/>.*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>


#define MATHG_TYPE_NUMBER_UTILS (mathg_number_utils_get_type ())
typedef struct _mathgNumberUtils mathgNumberUtils;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _mathgNumberUtils {
	gint bas;
};



GType mathg_number_utils_get_type (void) G_GNUC_CONST;
mathgNumberUtils* mathg_number_utils_dup (const mathgNumberUtils* self);
void mathg_number_utils_free (mathgNumberUtils* self);
void mathg_number_utils_init (mathgNumberUtils *self, const gchar* s);
gint mathg_number_utils_ti (mathgNumberUtils *self, const gchar* a);
gdouble mathg_number_utils_td (mathgNumberUtils *self, const gchar* a);
gint64 g_ascii_strtoll (const gchar* nptr, gchar** endptr, guint _base);
gchar* mathg_number_utils_ts (mathgNumberUtils *self, gdouble d);
#define MATHG_digits "0123456789abcdefghijklmnopqrstuvwxyz"
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


void mathg_number_utils_init (mathgNumberUtils *self, const gchar* s) {
	const gchar* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	g_return_if_fail (s != NULL);
	memset (self, 0, sizeof (mathgNumberUtils));
	_tmp0_ = s;
	_tmp1_ = mathg_number_utils_ti (&(*self), _tmp0_);
	(*self).bas = _tmp1_;
}


gdouble mathg_number_utils_td (mathgNumberUtils *self, const gchar* a) {
	gdouble result = 0.0;
	const gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	const gchar* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	gdouble _tmp6_ = 0.0;
	g_return_val_if_fail (a != NULL, 0.0);
	_tmp0_ = a;
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, ".", 0);
	_tmp3_ = _tmp2_;
	_tmp3__length1 = _vala_array_length (_tmp1_);
	_tmp4_ = _tmp3_[0];
	_tmp5_ = mathg_number_utils_ti (&(*self), _tmp4_);
	_tmp6_ = (gdouble) _tmp5_;
	_tmp3_ = (_vala_array_free (_tmp3_, _tmp3__length1, (GDestroyNotify) g_free), NULL);
	result = _tmp6_;
	return result;
}


gint mathg_number_utils_ti (mathgNumberUtils *self, const gchar* a) {
	gint result = 0;
	const gchar* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint64 _tmp2_ = 0LL;
	g_return_val_if_fail (a != NULL, 0);
	_tmp0_ = a;
	_tmp1_ = (*self).bas;
	_tmp2_ = g_ascii_strtoll (_tmp0_, NULL, (guint) _tmp1_);
	result = (gint) _tmp2_;
	return result;
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_ = 0L;
	gchar _tmp1_ = '\0';
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


gchar* mathg_number_utils_ts (mathgNumberUtils *self, gdouble d) {
	gchar* result = NULL;
	gchar* s = NULL;
	gchar* _tmp0_ = NULL;
	gchar* t = NULL;
	gchar* _tmp1_ = NULL;
	gint i = 0;
	gdouble _tmp2_ = 0.0;
	gint j = 0;
	gint _tmp3_ = 0;
	const gchar* _tmp19_ = NULL;
	const gchar* _tmp20_ = NULL;
	gint _tmp21_ = 0;
	gchar _tmp22_ = '\0';
	gchar* _tmp23_ = NULL;
	gchar* _tmp24_ = NULL;
	const gchar* _tmp25_ = NULL;
	const gchar* _tmp26_ = NULL;
	gchar* _tmp27_ = NULL;
	gchar* _tmp28_ = NULL;
	_tmp0_ = g_strdup ("");
	s = _tmp0_;
	_tmp1_ = g_strdup ("");
	t = _tmp1_;
	_tmp2_ = d;
	i = (gint) _tmp2_;
	j = 0;
	_tmp3_ = i;
	if (_tmp3_ < 0) {
		gchar* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		_tmp4_ = g_strdup ("-");
		_g_free0 (t);
		t = _tmp4_;
		_tmp5_ = i;
		i = -_tmp5_;
	}
	while (TRUE) {
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		gint _tmp8_ = 0;
		gint _tmp9_ = 0;
		gint _tmp10_ = 0;
		gint _tmp11_ = 0;
		gint _tmp12_ = 0;
		gchar _tmp13_ = '\0';
		gchar* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		const gchar* _tmp17_ = NULL;
		gchar* _tmp18_ = NULL;
		_tmp6_ = i;
		_tmp7_ = (*self).bas;
		if (!(_tmp6_ >= _tmp7_)) {
			break;
		}
		_tmp8_ = i;
		_tmp9_ = (*self).bas;
		j = _tmp8_ % _tmp9_;
		_tmp10_ = i;
		_tmp11_ = (*self).bas;
		i = _tmp10_ / _tmp11_;
		_tmp12_ = j;
		_tmp13_ = string_get (MATHG_digits, (glong) _tmp12_);
		_tmp14_ = g_strdup_printf ("%c", _tmp13_);
		_tmp15_ = _tmp14_;
		_tmp16_ = s;
		_tmp17_ = string_to_string (_tmp16_);
		_tmp18_ = g_strconcat (_tmp15_, _tmp17_, NULL);
		_g_free0 (s);
		s = _tmp18_;
		_g_free0 (_tmp15_);
	}
	_tmp19_ = t;
	_tmp20_ = string_to_string (_tmp19_);
	_tmp21_ = i;
	_tmp22_ = string_get (MATHG_digits, (glong) _tmp21_);
	_tmp23_ = g_strdup_printf ("%c", _tmp22_);
	_tmp24_ = _tmp23_;
	_tmp25_ = s;
	_tmp26_ = string_to_string (_tmp25_);
	_tmp27_ = g_strconcat (_tmp20_, _tmp24_, _tmp26_, NULL);
	_tmp28_ = _tmp27_;
	_g_free0 (_tmp24_);
	result = _tmp28_;
	_g_free0 (t);
	_g_free0 (s);
	return result;
}


mathgNumberUtils* mathg_number_utils_dup (const mathgNumberUtils* self) {
	mathgNumberUtils* dup;
	dup = g_new0 (mathgNumberUtils, 1);
	memcpy (dup, self, sizeof (mathgNumberUtils));
	return dup;
}


void mathg_number_utils_free (mathgNumberUtils* self) {
	g_free (self);
}


GType mathg_number_utils_get_type (void) {
	static volatile gsize mathg_number_utils_type_id__volatile = 0;
	if (g_once_init_enter (&mathg_number_utils_type_id__volatile)) {
		GType mathg_number_utils_type_id;
		mathg_number_utils_type_id = g_boxed_type_register_static ("mathgNumberUtils", (GBoxedCopyFunc) mathg_number_utils_dup, (GBoxedFreeFunc) mathg_number_utils_free);
		g_once_init_leave (&mathg_number_utils_type_id__volatile, mathg_number_utils_type_id);
	}
	return mathg_number_utils_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



